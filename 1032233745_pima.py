# -*- coding: utf-8 -*-
"""1032233745_PIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mfe_RKwYRsEPqBIzXzCdJTDIiXg6Z19Q

**Assignment 1**
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv('diabetes.csv')

print(df)

print(df.head())

print(df.tail(2))

print(df.columns)

print(df['BMI'].head(10))

print(df.shape)

print(df.iloc[:,4])

"""df.iloc[] is used for integer based indexing"""

print(df[119:121])

"""This too does integer based indexing but only for rows, not columns"""

print(df.describe())

"""Returns the count, mean, std, min, max, etc."""

print(df.info())

"""Returns information like columns, non-null count, dtype, memory, usage, etc"""

print(df['Age'].mean())

print(df.mean(axis=0))

"""axis = 0 -> Column-wise mean

axis = 1 -> Row-wise mean
"""

print(df.std())

"""**Assignment 2**"""

print(df.isnull())

print(df.duplicated())

"""*   A row is considered a duplicate if it has identical values in all columns compared to a previous row (by default).
*   The first occurrence of a duplicate row is marked as False, and subsequent occurrences are marked as True.
"""

print(df.drop_duplicates(inplace=True))

print(df.drop_duplicates())

"""The df.drop_duplicates() method in pandas removes duplicate rows from a DataFrame and returns a new DataFrame (or modifies the original if inplace=True) with only the first occurrence of each duplicate row retained by default."""

print(df[['Age','BMI']])

print(df.interpolate(axis=0, inplace=True))

"""The df.interpolate() method in pandas fills in missing (NaN) values in a DataFrame by interpolating between existing values. It works by estimating the missing values based on other data in the DataFrame."""

print(df.dropna())

print(df.fillna(0))

"""**Assignment 3**"""

data = [[6, 12], [7, 11], [8, 14], [9, 7], [8, 13], [5, 9], [10, 11], [9, 15], [7, 10]]
student_df = pd.DataFrame(data, columns=['CCA1', 'CCA2'])
corr = student_df.corr(method='pearson')
print(corr)

"""In the above calculated correlation coefficient values, we can observe that the correlation is equal for CCA1 and CCA2"""

plt.figure(figsize=(10,3))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('Correlation heatmap')
plt.show()

df.hist(figsize=(10,10),bins=50)
plt.title('Histogram')
plt.show()

for column in df.columns:
  plt.figure(figsize=(2,2))
  sns.kdeplot(df[column], label=column)
  plt.title(f'Density plot of {column}')
  plt.legend
  plt.show()

plt.figure(figsize=(15,5))
sns.boxplot(data=df.select_dtypes(include=[np.number]))
plt.title('Boxplot')
plt.show()

plt.figure(figsize=(2,2))
sns.pairplot(df.select_dtypes(include=[np.number]))
plt.title('Scatter Plot')
plt.show()

df_minmax = df.copy()
print(df_minmax['Age'])

numeric_columns = df.select_dtypes(include=[np.number]).columns
df_minmax = df[numeric_columns].apply(lambda x: (x - x.min()) / (x.max() - x.min()))
print(df_minmax)

df_z = df[numeric_columns].apply(lambda x: (x - x.mean()) / x.std())
print(df_z)

df_binning = df.copy()

for column in numeric_columns:
  df_binning[f'{column}_binned'] = pd.cut(df_binning[column], bins = 10, labels = False)
print(df_binning)